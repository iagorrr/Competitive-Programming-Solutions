#include <bits/stdc++.h>
using namespace std;

/*

   	* três é meio chato só bruta ele mesmo

	quando é impar:
		print o x

		se x >= teto(n/2):
			faz o desce sobe começando do teto(n/2)
		else:
			faz o sobe desce começando do teto(n/2)

		sempre que faltar :
			se ta subindo da mais um ++
			se tá descendo da mais um --

	quando é par:
		printa o x

		se x < n/2 + 1:
			sobe desce começando do n/2 + 1		
		else:
			sobe desce começando do  n/2

		mesmo esquema do ++ e --

	1
	    1 (0)

	2
	    1 2 (1)

	    2 1 (1)

	3
	    1 2 3 (1)
	    1 3 2 (1)

	    2 1 3 (2)
	    2 3 1 (2)

	    3 1 2 (1)
	    3 2 1 (1)

	4
	    1 2 4 3 (2)
	    1 3 2 4 (2)
	    1 3 4 2 (2)

	    2 3 1 4 (3)

	    3 2 4 1 (3)

	    4 2 1 3 (2)
	    4 2 3 1 (2)
	    4 3 1 2 (2)

	5
	    1 3 4 2 5 (3)
	    1 4 3 5 2 (3)

	    2 3 1 4 5 (3)
	    2 3 1 5 4 (3)
	    2 3 4 1 5 (3)
	    2 3 5 1 4 (3)
	    2 3 5 4 1 (3)
	    2 4 1 5 3 (3)
	    2 4 3 1 5 (3)
	    2 4 3 5 1 (3)

	    3 2 4 1 5 (4)
	    3 4 2 5 1 (4)

	    4 2 3 1 5 (3)
	    4 2 3 5 1 (3)
	    4 2 5 1 3 (3)
	    4 3 1 2 5 (3)
	    4 3 1 5 2 (3)
	    4 3 2 5 1 (3)
	    4 3 5 1 2 (3)
	    4 3 5 2 1 (3)

	    5 2 3 1 4 (3)
	    5 3 2 4 1 (3)

	6
	    1 4 3 5 2 6 (4)
	    1 4 5 3 6 2 (4)

	    2 3 5 1 6 4 (4)
	    2 3 5 4 1 6 (4)
	    2 3 6 4 1 5 (4)
	    2 4 3 5 1 6 (4)
	    2 4 5 3 6 1 (4)

	    3 4 2 5 1 6 (5)

	    4 3 5 2 6 1 (5)

	    5 3 2 4 1 6 (4)
	    5 3 4 2 6 1 (4)
	    5 4 1 3 6 2 (4)
	    5 4 2 3 6 1 (4)
	    5 4 2 6 1 3 (4)

	    6 3 2 4 1 5 (4)
	    6 3 4 2 5 1 (4)

	7
	    1 4 5 3 6 2 7 (5)
	    1 5 4 6 3 7 2 (5)

	    2 4 5 3 6 1 7 (5)
	    2 5 4 6 3 7 1 (5)

	    3 2 4 7 5 1 6 (5)
	    3 4 2 5 1 6 7 (5)
	    3 4 2 5 1 7 6 (5)
	    3 4 2 5 6 1 7 (5)
	    3 4 2 6 1 7 5 (5)
	    3 4 5 2 6 1 7 (5)
	    3 4 6 2 5 1 7 (5)
	    3 4 6 2 7 1 5 (5)
	    3 4 6 5 2 7 1 (5)
	    3 4 7 5 2 6 1 (5)
	    3 5 2 6 1 7 4 (5)
	    3 5 4 2 6 1 7 (5)
	    3 5 4 6 2 7 1 (5)

	    4 3 5 2 6 1 7 (6)
	    4 5 3 6 2 7 1 (6)

	    5 3 4 2 6 1 7 (5)
	    5 3 4 6 2 7 1 (5)
	    5 3 6 2 7 1 4 (5)
	    5 4 1 3 6 2 7 (5)
	    5 4 2 3 6 1 7 (5)
	    5 4 2 6 1 7 3 (5)
	    5 4 2 6 3 7 1 (5)
	    5 4 3 6 2 7 1 (5)
	    5 4 6 2 7 1 3 (5)
	    5 4 6 3 2 7 1 (5)
	    5 4 6 3 7 1 2 (5)
	    5 4 6 3 7 2 1 (5)
	    5 6 4 1 3 7 2 (5)

	    6 3 4 2 5 1 7 (5)
	    6 4 3 5 2 7 1 (5)

	    7 3 4 2 5 1 6 (5)
	    7 4 3 5 2 6 1 (5)

	8
	    1 5 4 6 3 7 2 8 (6)
	    1 5 6 4 7 3 8 2 (6)

	    2 3 5 8 4 6 1 7 (6)
	    2 5 4 6 3 7 1 8 (6)
	    2 5 6 4 7 3 8 1 (6)

	    3 4 6 2 7 1 8 5 (6)
	    3 4 6 5 2 7 1 8 (6)
	    3 4 7 5 2 6 1 8 (6)
	    3 5 4 6 2 7 1 8 (6)
	    3 5 6 4 7 2 8 1 (6)

	    4 5 3 6 2 7 1 8 (7)

	    5 4 6 3 7 2 8 1 (7)

	    6 4 3 5 2 7 1 8 (6)
	    6 4 5 3 7 2 8 1 (6)
	    6 5 2 4 7 3 8 1 (6)
	    6 5 3 4 7 2 8 1 (6)
	    6 5 3 7 2 8 1 4 (6)

	    7 4 3 5 2 6 1 8 (6)
	    7 4 5 3 6 2 8 1 (6)
	    7 6 4 1 5 3 8 2 (6)

	    8 4 3 5 2 6 1 7 (6)
	    8 4 5 3 6 2 7 1 (6)

	9
	    1 5 6 4 7 3 8 2 9 (7)
	    1 6 5 7 4 8 3 9 2 (7)

	    2 5 6 4 7 3 8 1 9 (7)
	    2 6 5 7 4 8 3 9 1 (7)

	    3 4 6 9 5 2 7 1 8 (7)
	    3 4 6 9 5 7 2 8 1 (7)
	    3 5 6 4 7 2 8 1 9 (7)
	    3 6 5 7 4 8 2 9 1 (7)

	    4 3 5 8 6 2 7 1 9 (7)
	    4 3 5 9 6 2 7 1 8 (7)
	    4 5 3 6 2 7 1 8 9 (7)
	    4 5 3 6 2 7 1 9 8 (7)
	    4 5 3 6 2 7 8 1 9 (7)
	    4 5 3 6 2 8 1 9 7 (7)
	    4 5 3 6 7 2 8 1 9 (7)
	    4 5 3 7 2 8 1 9 6 (7)
	    4 5 3 9 6 2 7 1 8 (7)
	    4 5 6 3 7 2 8 1 9 (7)
	    4 5 7 3 6 2 8 1 9 (7)
	    4 5 7 3 8 2 9 1 6 (7)
	    4 5 7 6 3 8 2 9 1 (7)
	    4 5 8 6 3 7 2 9 1 (7)
	    4 6 3 7 2 8 1 9 5 (7)
	    4 6 5 3 7 2 8 1 9 (7)
	    4 6 5 7 3 8 2 9 1 (7)

	    5 4 6 3 7 2 8 1 9 (8)
	    5 6 4 7 3 8 2 9 1 (8)

	    6 4 5 3 7 2 8 1 9 (7)
	    6 4 5 7 3 8 2 9 1 (7)
	    6 4 7 3 8 2 9 1 5 (7)
	    6 5 2 4 7 3 8 1 9 (7)
	    6 5 3 4 7 2 8 1 9 (7)
	    6 5 3 7 2 8 1 9 4 (7)
	    6 5 3 7 4 8 2 9 1 (7)
	    6 5 4 7 3 8 2 9 1 (7)
	    6 5 7 1 4 8 3 9 2 (7)
	    6 5 7 3 8 2 9 1 4 (7)
	    6 5 7 4 3 8 2 9 1 (7)
	    6 5 7 4 8 2 9 1 3 (7)
	    6 5 7 4 8 3 2 9 1 (7)
	    6 5 7 4 8 3 9 1 2 (7)
	    6 5 7 4 8 3 9 2 1 (7)
	    6 7 5 1 4 8 3 9 2 (7)
	    6 7 5 2 4 8 3 9 1 (7)

	    7 4 5 3 6 2 8 1 9 (7)
	    7 5 4 6 3 8 2 9 1 (7)
	    7 6 4 1 5 3 8 2 9 (7)
	    7 6 4 1 5 8 3 9 2 (7)

	    8 4 5 3 6 2 7 1 9 (7)
	    8 5 4 6 3 7 2 9 1 (7)

	    9 4 5 3 6 2 7 1 8 (7)
	    9 5 4 6 3 7 2 8 1 (7)

	10
	    1 6 5 7 4 8 3 9 2 10 (8)
	    1 6 7 5 8 4 9 3 10 2 (8)

	    2 6 5 7 4 8 3 9 1 10 (8)
	    2 6 7 5 8 4 9 3 10 1 (8)

	    3 4 6 9 5 7 2 8 1 10 (8)
	    3 6 5 7 4 8 2 9 1 10 (8)
	    3 6 7 5 8 4 9 2 10 1 (8)

	    4 5 3 6 10 7 2 8 1 9 (8)
	    4 5 7 3 8 2 9 1 10 6 (8)
	    4 5 7 6 3 8 2 9 1 10 (8)
	    4 5 7 10 6 3 8 2 9 1 (8)
	    4 5 8 6 3 7 2 9 1 10 (8)
	    4 6 5 7 3 8 2 9 1 10 (8)
	    4 6 7 5 8 3 9 2 10 1 (8)

	    5 6 4 7 3 8 2 9 1 10 (9)

	    6 5 7 4 8 3 9 2 10 1 (9)

	    7 5 4 6 3 8 2 9 1 10 (8)
	    7 5 6 4 8 3 9 2 10 1 (8)
	    7 6 3 5 8 4 9 2 10 1 (8)
	    7 6 4 1 5 8 3 9 2 10 (8)
	    7 6 4 5 8 3 9 2 10 1 (8)
	    7 6 4 8 3 9 2 10 1 5 (8)
	    7 6 8 5 1 4 9 3 10 2 (8)

	    8 5 4 6 3 7 2 9 1 10 (8)
	    8 5 6 4 7 3 9 2 10 1 (8)
	    8 7 5 2 6 4 9 3 10 1 (8)

	    9 5 4 6 3 7 2 8 1 10 (8)
	    9 5 6 4 7 3 8 2 10 1 (8)

	    10 5 4 6 3 7 2 8 1 9 (8)
	    10 5 6 4 7 3 8 2 9 1 (8)

	11
	    1 6 7 5 8 4 9 3 10 2 11 (9)
	    1 7 6 8 5 9 4 10 3 11 2 (9)

	    2 6 7 5 8 4 9 3 10 1 11 (9)
	    2 7 6 8 5 9 4 10 3 11 1 (9)

	    3 6 7 5 8 4 9 2 10 1 11 (9)
	    3 7 6 8 5 9 4 10 2 11 1 (9)

	    4 5 7 10 6 3 8 2 9 1 11 (9)
	    4 5 7 10 6 8 3 9 2 11 1 (9)
	    4 6 7 5 8 3 9 2 10 1 11 (9)
	    4 7 6 8 5 9 3 10 2 11 1 (9)

	    5 4 6 9 7 3 8 2 10 1 11 (9)
	    5 4 6 10 7 3 8 2 9 1 11 (9)
	    5 6 4 7 3 8 2 9 1 10 11 (9)
	    5 6 4 7 3 8 2 9 1 11 10 (9)
	    5 6 4 7 3 8 2 9 10 1 11 (9)
	    5 6 4 7 3 8 2 10 1 11 9 (9)
	    5 6 4 7 3 8 9 2 10 1 11 (9)
	    5 6 4 7 3 9 2 10 1 11 8 (9)
	    5 6 4 7 8 3 9 2 10 1 11 (9)
	    5 6 4 7 11 3 8 2 9 1 10 (9)
	    5 6 4 7 11 8 3 9 2 10 1 (9)
	    5 6 4 8 3 9 2 10 1 11 7 (9)
	    5 6 4 10 7 3 8 2 9 1 11 (9)
	    5 6 7 4 8 3 9 2 10 1 11 (9)
	    5 6 8 4 7 3 9 2 10 1 11 (9)
	    5 6 8 4 9 3 10 2 11 1 7 (9)
	    5 6 8 7 4 9 3 10 2 11 1 (9)
	    5 6 9 7 4 8 3 10 2 11 1 (9)
	    5 7 4 8 3 9 2 10 1 11 6 (9)
	    5 7 6 4 8 3 9 2 10 1 11 (9)
	    5 7 6 8 4 9 3 10 2 11 1 (9)

	    6 5 7 4 8 3 9 2 10 1 11 (10)
	    6 7 5 8 4 9 3 10 2 11 1 (10)

	    7 5 6 4 8 3 9 2 10 1 11 (9)
	    7 5 6 8 4 9 3 10 2 11 1 (9)
	    7 5 8 4 9 3 10 2 11 1 6 (9)
	    7 6 3 5 8 4 9 2 10 1 11 (9)
	    7 6 4 5 8 3 9 2 10 1 11 (9)
	    7 6 4 8 3 9 2 10 1 11 5 (9)
	    7 6 4 8 5 9 3 10 2 11 1 (9)
	    7 6 5 8 4 9 3 10 2 11 1 (9)
	    7 6 8 2 5 9 4 10 3 11 1 (9)
	    7 6 8 4 9 3 10 2 11 1 5 (9)
	    7 6 8 5 1 4 9 3 10 2 11 (9)
	    7 6 8 5 1 9 4 10 3 11 2 (9)
	    7 6 8 5 4 9 3 10 2 11 1 (9)
	    7 6 8 5 9 3 10 2 11 1 4 (9)
	    7 6 8 5 9 4 3 10 2 11 1 (9)
	    7 6 8 5 9 4 10 2 11 1 3 (9)
	    7 6 8 5 9 4 10 3 2 11 1 (9)
	    7 6 8 5 9 4 10 3 11 1 2 (9)
	    7 6 8 5 9 4 10 3 11 2 1 (9)
	    7 8 6 2 5 9 4 10 3 11 1 (9)
	    7 8 6 3 5 9 4 10 2 11 1 (9)

	    8 5 6 4 7 3 9 2 10 1 11 (9)
	    8 6 5 7 4 9 3 10 2 11 1 (9)
	    8 7 5 2 6 4 9 3 10 1 11 (9)
	    8 7 5 2 6 9 4 10 3 11 1 (9)

	    9 5 6 4 7 3 8 2 10 1 11 (9)
	    9 6 5 7 4 8 3 10 2 11 1 (9)

	    10 5 6 4 7 3 8 2 9 1 11 (9)
	    10 6 5 7 4 8 3 9 2 11 1 (9)

	    11 5 6 4 7 3 8 2 9 1 10 (9)
	    11 6 5 7 4 8 3 9 2 10 1 (9)

	12
 */

 template <typename T>
pair<int, vector<int>> lis(const vector<T> &xs) {
  int n = xs.size();

  vector<T> dp(n + 1, numeric_limits<T>::max());
  dp[0] = numeric_limits<T>::min();

  int sz = 0;
  vector<int> psx(n);

  for (int i = 0; i < n; i++) {
    auto it = lower_bound(dp.begin(), dp.end(), xs[i]);
    auto pos = (int)(it - dp.begin());

    sz = max(sz, pos);

    dp[pos] = xs[i];

    psx[i] = pos;
  }

  return {sz, psx};
}

template <typename T>
vector<int> get_idx(vector<T> xs) {
  auto [sz1, psx1] = lis(xs);

  reverse(xs.begin(), xs.end());
  for (auto &xi : xs) xi = -xi;

  auto [sz2, psx2] = lis(xs);

  vector<int> ans;
  int _n = xs.size();
  for (int i = 0; i < _n; i++) {
    int l = psx1[i];
    int r = psx2[_n - i - 1];
    if (l + r - 1 == sz1) ans.push_back(i);
  }

  return ans;
}

void down_up(int n, int x, int s) {
	vector<int> ans(1, x);


	int l = s, r = s;
	for (int i = 2; i <= n; i++) {
		if (i % 2 == 0) {
			if (r == x) r++;
			ans.push_back(r);

			r++;
		}
		else {
			l--;
			if(l==x) l--;
			ans.push_back(l);
		}
	}

	for (auto i : ans) cout << i << " ";
	cout << '\n';

	vector<int> aux;
	for (int i = 0; i + 1 < ans.size(); i++) {
		aux.push_back(abs(ans[i]-ans[i+1]));
	}
	auto [sz, _] = lis(aux);
	int k = n&1 ? x == (n+1)/2 : (x == n/2+1) or (x == n/2);
	assert(n - 2 + k == sz);
}

void up_down(int n, int x, int s) {
	vector<int> ans(1, x);
	int l = s,  r = s;
	for (int i = 2; i <= n; i++) {
		if (i & 1) {
			r++;
			if (r == x) r++;
			ans.push_back(r);
		}
		else {
			if (l == x) l--;
			ans.push_back(l);
			l--;
		}
	}



	for (auto i : ans) cout << i << " ";
	cout << '\n';


	vector<int> aux;
	for (int i = 0; i + 1 < ans.size(); i++) {
		aux.push_back(abs(ans[i]-ans[i+1]));
	}
	auto [sz, _] = lis(aux);
	int k = n&1 ? x == (n+1)/2 : (x == n/2+1) or (x== n/2);
	assert(n - 2 + k == sz);

}

int32_t main() {
	ios_base::sync_with_stdio(0);
	cin.tie(0);

	int n, x;
	cin >> n >> x;

	if (n == 1) {
		cout << 1 << '\n';
		return 0;
	}

	if (n == 2 and x == 1) {
		cout << "1 2\n";
		return 0;
	}

	if (n == 3 and x == 2) {
		cout << "2 1 3\n";
		return 0;
	}


	if (n == 3 and x == 1) {
		cout << "1 2 3\n";
		return 0;
	}

	if (n == 3 and x == 1) {
		cout << "3 1 2\n";
		return 0;
	}

	if (n & 1)  {
		if (x >= (n+1)/2) {
			down_up(n, x, (n+1)/2);
		}
		else {
			up_down(n, x, (n+1)/2);
		}
	}
	else {
		if (x == n /2) {
			down_up(n, x, n/2+1);
		}
		else if (x < n/2 + 1) {
			up_down(n, x, n/2 + 1);
		}
		else {
			up_down(n, x, n/2);
		}
	}
}

// AC, constructive algorithms, brute force, permutations
